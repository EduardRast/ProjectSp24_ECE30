main:	lda x4, start
	ldur x0, [x4, #0]
	bl FindTail
	addi x2, x1, #24
	stur x2, [sp, #0]
	bl Partition
	STOP


FindTail:
	SUBI SP, SP, #64
	STUR FP, [SP, #0]
	ADDI FP, SP, #56
	STUR LR, [SP, #8]
	//ADD X1, X1, X0 // x1 = x0

if_tail: 
	LDUR X9, [X0, #16] // *(pt + 2)
	ADDIS XZR, X9, #1 // *(pt + 2) = -1
	B.EQ rettail
else_tail:
	//STUR X0, [SP, #16] // backup X0
	ADDI X0, X0, #16 // pt = pt + 2
	//ADD X1, X1, X0 // x1 = x0 // figure out where to put this
	BL FindTail
	//LDUR X0, [SP, #16] // reload X0

rettail:
	ADD X1, XZR, X0
	LDUR FP, [SP, #0]
	LDUR LR, [SP, #8]
	ADDI SP, SP, #64
	BR LR	

FindMidpoint:
	// input:
	// x0: address of (pointer to) the first symbol of the symbol array
	// x1: address of (pointer to) the last symbol of the symbol array
	// x2: sum of the frequency of the left sub-array
	// x3: sum of the frequency of the right sub-array
	
	// output:
	// x4: address of (pointer to) the first element of the right-hand side sub-array


	SUBI	SP, SP, #64	// Allocate 32 bytes of memory (4 double words) to this function
	STUR	FP, [SP, #0]	// FP of parent is saved onto my stack SP+0
	STUR	LR, [SP, #8]	// LR should be saved to retrieve it later
	ADDI	FP, SP, #56	// FP is moved up from parent's to mine

if_mid:	ADD X4, XZR, X1 // stores tail in return register
	ADDI X9, X0, #16 // checks if head + 2 == tail and returns tail if yes
	SUBS XZR, X9, X4 // using X9 for temp storage
	B.EQ retmid
else_mid:
	STUR X0, [SP, #16]	// First, make sure we backup registers that we need and are our
	STUR X1, [SP, #24]
	STUR X2, [SP, #32]
	STUR X3, [SP, #40]
	//STUR X4, [SP, #48]
	SUBS XZR, X2, X3 // checks left_sum <= right_sum
	B.LE if2_mid
	// nested else statement
else2_mid:	
	SUBI X1, X1, #16 //tail = tail - 2
	LDUR X10, [X1, #8] // *(tail + 1)
	ADD X3, X3, X10 //right_sum = right_sum + *(tail + 1)
	B endif_mid
// nested if statement
if2_mid:
	
	ADDI X0, X0, #16 // head = head + 2
	LDUR X10, [X0, #8] // X10 has *(head + 1)
	ADD X2, X2, X10 // left_sum = left_sum + *(head + 1)
endif_mid:
	BL FindMidpoint // call FindMidpoint recursively
	LDUR X0, [SP, #16]	// Restore the value of registers that we backed up
	LDUR X1, [SP, #24]
	LDUR X2, [SP, #32]
	LDUR X3, [SP, #40]
	//LDUR X4, [SP, #48]
retmid:
	LDUR	FP, [SP, #0]	// Restore FP to what it was at the start
	LDUR	LR, [SP, #8]	// Restore LR to what it was at the start
	ADDI	SP, SP, #64	// Free up the space we took on stack by moving SP	
	br lr
	




Partition:
	// input:
	// x0: address of (pointer to) the first symbol of the symbol array
	// x1: address of (pointer to) the last symbol of the symbol array
	// x2: address of the first attribute of the current binary tree node

	SUBI	SP, SP, #64	// Allocate 64 bytes of memory (4 double words) to this function
	STUR	FP, [SP, #0]	// FP of parent is saved onto my stack SP+0
	STUR	LR, [SP, #8]	// LR should be saved to retrieve it later
	ADDI	FP, SP, #56	// FP is moved up from parent's to mine


	STUR X0, [X2, #0] //*node = start
	STUR X1, [X2, #8] //*(node+1) = end
if_part:
	SUBS XZR, X0, X1 // checks if start = end
	B.NE else_part
	SUBI X9, XZR, #1 // storing NULL in X9
	STUR X9, [X2, #16] // *(node + 2) = NULL
	STUR X9, [X2, #24] // *(node + 3) = NULL
	B retpart
	
else_part:
	STUR X0, [SP, #16]	// First, make sure we backup registers that we need and are our
	STUR X1, [SP, #24]
	STUR X2, [SP, #32]

	
	LDUR X2, [X0, #8] // left_sum = *(start + 1)
	LDUR X3, [X1, #8] // right_sum = *(end + 1)
	
	BL FindMidpoint
	LDUR X0, [SP, #16]	// Restore the value of registers that we backed up
	LDUR X1, [SP, #24]
	LDUR X2, [SP, #32]

	ADD X10, X4, XZR // storing midpoint in X10
	SUB X11, X10, X0 // offset = midpoint - start
	SUBI X11, X11, #1 // offset = midpoint - start - 1
	ADDI X12, X2, #32 // left_node = node + 4
	LSL X11, X11, #2 // offset * 4
	ADD X13, X12, X11 // right_node = node + 4 + offset * 4
	STUR X12, [X2, #16] // *(node+2) = left_node
	STUR X13, [X2, #24] // *(node+3) = right_node

	SUBI X1, X10, #2 // end = midpoint - 2 before partition call
	ADD X2, X12, XZR // node = left_node before partition call
	BL Partition
	LDUR X0, [SP, #16]	// Restore the value of registers that we backed up
	LDUR X1, [SP, #24]
	LDUR X2, [SP, #32]
	

	ADD X0, X10, XZR // start = midpoint before partition call
	ADD X2, X13, XZR // node = right_node before partition call
	BL Partition
	LDUR X0, [SP, #16]	// Restore the value of registers that we backed up
	LDUR X1, [SP, #24]
	LDUR X2, [SP, #32]
	

retpart:
	LDUR	FP, [SP, #0]	// Restore FP to what it was at the start
	LDUR	LR, [SP, #8]	// Restore LR to what it was at the start
	ADDI	SP, SP, #64	// Free up the space we took on stack by moving SP
	
	br lr